[
  {
    "testCaseId": "test_001",
    "testCaseName": "Monolithic to Microservices Migration",
    "phase": "phase1",
    "output": "# Monolithic to Microservices Migration\n\n## Status\nProposed\n\n## Context\nOur e-commerce platform is built as a monolith with growing scalability issues. \n        Customer base has grown 300% in 18 months, causing database bottlenecks and slow deployments.\n        The system has tight coupling between order processing, inventory management, and payment processing.\n        Deployments take 45 minutes and lock the database, causing 2-3 hour outages weekly.\n        Our team now spans 5 domains with conflicting deployment schedules.\n\n## Decision\nWe considered the strangler pattern (slower migration, $200k cost to maintain dual systems) and monolith optimization (addressable only for 50% of bottlenecks), but will migrate from a monolithic architecture to domain-driven microservices with each business domain owning its database and deploying independently. This addresses the 300% customer growth that has made horizontal scaling impossible and reduces deployment time from 45 minutes to 5 minutes per service.\n\n## Consequences\n\n### Positive Consequences\n- Reduces deployment time from 45 minutes to 5 minutes per service, eliminating synchronized release windows and production outage risks\n- Enables individual teams to scale services independently based on actual demand; order processing can scale 10x without scaling inventory\n- Allows domain teams to adopt appropriate technology stacks per domain; removes one-size-fits-all technology constraints\n- Reduces team wait times on shared infrastructure; teams no longer block each other on database schema changes or deployment coordination\n\n### Negative Consequences\n- Requires implementing distributed systems patterns: eventual consistency replaces ACID transactions, requiring event-driven architecture and compensation logic\n- Increases network latency: inter-service calls add 50-100ms per hop, requiring caching strategies and circuit breakers throughout the system\n- Requires new expertise in message queues (Kafka, RabbitMQ), distributed tracing (Jaeger), and service mesh; estimated 6-8 weeks team training\n- Increases operational complexity: surface area grows from 1 deployment artifact to 10+, requiring Kubernetes orchestration and observability infrastructure\n\n### Subsequent ADRs Triggered by This Decision\n- Service mesh selection (Istio vs. Linkerd for inter-service communication)\n- Distributed tracing implementation (Jaeger vs. Zipkin for observability)\n- API gateway strategy (Kong vs. AWS API Gateway for public interfaces)\n\n### Recommended Review Timing\nReview in 30 days to validate deployment time improvements against 5-minute target and measure inter-service latency vs. 50-100ms assumption.",
    "score": 3.8481792717086836,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": true
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": false
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": false
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": true
        },
        {
          "name": "Addresses root cause from context",
          "passed": false
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": false
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  },
  {
    "testCaseId": "test_002",
    "testCaseName": "Frontend Framework Migration",
    "phase": "phase1",
    "output": "# Frontend Framework Migration\n\n## Status\nProposed\n\n## Context\nOur 5-year-old jQuery-based admin dashboard has become unmaintainable.\n        It takes new developers 6 weeks to become productive. The codebase has no tests.\n        We're losing features to competitors with better UX. Customer feedback shows frustration with performance.\n        Our team of 8 frontend developers spends 40% of time on bug fixes rather than features.\n        Modern frameworks offer better component reusability and testing support.\n\n## Decision\nWe considered Angular (steep learning curve, 8-week ramp-up) and Vue (smaller ecosystem, less team expertise available), but will migrate our jQuery-based admin dashboard to React with TypeScript. This directly addresses the 6-week onboarding time for new developers and the 40% of engineering time lost to bugs rather than feature development, bringing us to industry-standard frontend velocity.\n\n## Consequences\n\n### Positive Consequences\n- Reduces developer onboarding from 6 weeks to 2 weeks through component reusability and clear patterns\n- Enables automated testing: component test coverage increases from 0% to 80%+ within first quarter through Jest and React Testing Library\n- Reduces bug-related work from 40% to 10% of sprint time through TypeScript type safety preventing runtime errors and component isolation preventing state leaks\n- Reduces initial page load from 8s to 2s through lazy-loading and bundle optimization; reduces time-to-interactive from 12s to 4s\n\n### Negative Consequences\n- Requires React and TypeScript expertise; team needs 4-week ramp-up period before productive at target velocity\n- Migration effort is 6-8 weeks for existing features; requires parallel implementation to avoid downtime\n- Adds new toolchain burden with Webpack/Vite build system configuration, module bundling, and npm dependency management requirements\n- Introduces npm ecosystem security and supply-chain risks; requires dependency scanning with Snyk/Dependabot and transitive dependency management training\n\n### Subsequent ADRs Triggered by This Decision\n- Component library strategy (Storybook setup and maintenance patterns)\n- State management approach (Redux vs. Zustand vs. React Context)\n- Frontend testing framework (Jest + React Testing Library vs. Cypress for E2E)\n\n### Recommended Review Timing\nReview after first 3 quarterly feature releases to compare actual onboarding time against 2-week target and measure bug reduction impact.",
    "score": 4.005042016806722,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": false
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": true
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": false
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": true
        },
        {
          "name": "Addresses root cause from context",
          "passed": true
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": false
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  },
  {
    "testCaseId": "test_003",
    "testCaseName": "Database Technology Selection",
    "phase": "phase1",
    "output": "# Database Technology Selection\n\n## Status\nProposed\n\n## Context\nOur relational database stores 500GB of primarily unstructured operational logs and events.\n        Queries for analytics take 30+ minutes. Compliance requires we retain data for 7 years.\n        We're running out of disk space despite aggressive archiving.\n        Data structure is mostly key-value pairs with variable attributes.\n        Current quarterly costs are $150k for database infrastructure alone.\n\n## Decision\nWe considered column-based relational databases (expensive for this scale, $200k+ annual) and aggressive archiving of existing relational system (doesn't solve 30-minute query times), but will migrate our 500GB relational database containing primarily unstructured operational logs to a time-series database. This addresses the $150k quarterly cost and 30-minute analytics query latencies that block business decision-making.\n\n## Consequences\n\n### Positive Consequences\n- Reduces storage costs by 75% through compression and intelligent retention policies; quarterly cost drops from $150k to $37k\n- Reduces analytics query latency from 30 minutes to 30 seconds through columnar storage and time-series optimization\n- Enables real-time dashboards and automated alerts by supporting sub-second query response times for recent data windows (last 24 hours)\n- Enforces automatic compliance with data deletion regulations (GDPR, CCPA) through granular, policy-based retention that requires no manual intervention\n\n### Negative Consequences\n- Requires zero-downtime migration of 500GB data; dual-write period during migration increases database load 20%, requiring temporary capacity upgrade\n- Requires analytics team retraining: time-series query semantics differ significantly from relational; 3-4 weeks learning curve for new query patterns and aggregation methods\n- Eliminates relational query capabilities: complex joins become impossible; data models must restructure around time-series events rather than relational schemas\n- Requires either managed service ($5-10k/month) or dedicated ops expertise: time-series database clustering, replication, and backup procedures differ from relational databases\n\n### Subsequent ADRs Triggered by This Decision\n- Backup and disaster recovery strategy for time-series systems\n- Real-time alerting platform selection (Prometheus AlertManager vs. custom solution)\n- Data retention and compliance automation tooling\n\n### Recommended Review Timing\nReview after 60 days to validate cost savings against $37.5k quarterly target and verify query performance improvements from 30 minutes to 30 seconds.",
    "score": 4.193277310924369,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": true
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": false
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": true
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": true
        },
        {
          "name": "Addresses root cause from context",
          "passed": true
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": false
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  },
  {
    "testCaseId": "test_004",
    "testCaseName": "Authentication Strategy",
    "phase": "phase1",
    "output": "# Authentication Strategy\n\n## Status\nProposed\n\n## Context\nCurrently, each service manages its own user authentication using session cookies.\n        This causes inconsistent security policies and hard-to-audit login attempts.\n        We have 8 different services with 8 different password policies.\n        Security audit flagged 12 vulnerabilities related to inconsistent auth implementation.\n        New compliance requirement mandates multi-factor authentication across all services.\n\n## Decision\nWe considered per-service OAuth implementations (requires auditing 8 codebases, unmaintainable) and internal auth service (months to build, high risk), but will implement OAuth 2.0 single-sign-on through a managed identity provider. This resolves 12 OWASP authentication vulnerabilities from inconsistent implementations and enables mandatory multi-factor authentication across all 8 services.\n\n## Consequences\n\n### Positive Consequences\n- Eliminates 12 OWASP authentication vulnerabilities by consolidating session management, password handling, and credential validation into a single, audited service\n- Enables organization-wide password policy, MFA enforcement, and conditional access rules; compliance audits become straightforward and repeatable\n- Simplifies user experience: single password reset and single MFA enrollment grants access to all eight services\n- Reduces ongoing security maintenance burden: security team performs one quarterly review instead of auditing eight implementations\n\n### Negative Consequences\n- Creates single point of failure: authentication service outage immediately blocks all dependent services; requires 99.99% uptime SLA and comprehensive disaster recovery plan\n- Increases authentication latency: every user request requires round-trip to auth service (50-150ms added latency); requires aggressive token caching strategy\n- Requires rewriting authentication flows in eight services; estimated 4-6 weeks engineering effort for coordinated rollout with zero-downtime migration\n- Introduces external dependency on managed identity provider: adds $3-5k monthly cost, vendor lock-in, and integration complexity\n\n### Subsequent ADRs Triggered by This Decision\n- Token caching and refresh strategy (in-memory vs. Redis vs. local storage)\n- Session timeout and token lifetime policies\n- Multi-tenancy and cross-organization access control patterns\n\n### Recommended Review Timing\nReview after 14 days to verify zero security incidents and measure authentication latency impact against 50-150ms assumption.",
    "score": 4.1955182072829125,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": true
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": true
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": false
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": false
        },
        {
          "name": "Addresses root cause from context",
          "passed": true
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": true
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  },
  {
    "testCaseId": "test_005",
    "testCaseName": "API Versioning Strategy",
    "phase": "phase1",
    "output": "# API Versioning Strategy\n\n## Status\nProposed\n\n## Context\nOur public API has 1,200 active integrations with third-party developers.\n        We need to make breaking changes to support new business requirements.\n        We've deprecated v1 twice already, each time causing partner outages and support burden.\n        Current approach of maintaining multiple endpoint versions causes code duplication and inconsistency.\n        Partners request longer deprecation timelines (currently 6 months, asking for 18 months).\n\n## Decision\nWe considered per-service OAuth implementations (requires auditing 8 codebases, unmaintainable) and internal auth service (months to build, high risk), but will implement OAuth 2.0 single-sign-on through a managed identity provider. This resolves 12 OWASP authentication vulnerabilities from inconsistent implementations and enables mandatory multi-factor authentication across all 8 services.\n\n## Consequences\n\n### Positive Consequences\n- Eliminates 12 OWASP authentication vulnerabilities by consolidating session management, password handling, and credential validation into a single, audited service\n- Enables organization-wide password policy, MFA enforcement, and conditional access rules; compliance audits become straightforward and repeatable\n- Simplifies user experience: single password reset and single MFA enrollment grants access to all eight services\n- Reduces ongoing security maintenance burden: security team performs one quarterly review instead of auditing eight implementations\n\n### Negative Consequences\n- Creates single point of failure: authentication service outage immediately blocks all dependent services; requires 99.99% uptime SLA and comprehensive disaster recovery plan\n- Increases authentication latency: every user request requires round-trip to auth service (50-150ms added latency); requires aggressive token caching strategy\n- Requires rewriting authentication flows in eight services; estimated 4-6 weeks engineering effort for coordinated rollout with zero-downtime migration\n- Introduces external dependency on managed identity provider: adds $3-5k monthly cost, vendor lock-in, and integration complexity\n\n### Subsequent ADRs Triggered by This Decision\n- Token caching and refresh strategy (in-memory vs. Redis vs. local storage)\n- Session timeout and token lifetime policies\n- Multi-tenancy and cross-organization access control patterns\n\n### Recommended Review Timing\nReview after 14 days to verify zero security incidents and measure authentication latency impact against 50-150ms assumption.",
    "score": 4.038655462184873,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": true
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": true
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": false
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": false
        },
        {
          "name": "Addresses root cause from context",
          "passed": false
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": true
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  }
]