[
  {
    "testCaseId": "test_001",
    "testCaseName": "Monolithic to Microservices Migration",
    "phase": "phase3",
    "output": "# Monolithic to Microservices Migration\n\n## Status\nProposed\n\n## Context\nOur e-commerce platform is built as a monolith with growing scalability issues. \n        Customer base has grown 300% in 18 months, causing database bottlenecks and slow deployments.\n        The system has tight coupling between order processing, inventory management, and payment processing.\n        Deployments take 45 minutes and lock the database, causing 2-3 hour outages weekly.\n        Our team now spans 5 domains with conflicting deployment schedules.\n\n## Decision\nWe evaluated the strangler pattern (slow, expensive to maintain dual systems) and monolith optimization (solves only 50% of bottlenecks), but will migrate from monolithic architecture to domain-driven microservices with each domain owning its complete data store and deploying independently on a weekly cadence. This directly addresses the 300% customer growth that has made our current monolith unable to scale beyond 45-minute deployments, eliminating production outage risk from coordinated releases.\n\n## Consequences\n\n### Positive Consequences\n- Reduces deployment time from 45-minute coordinated releases to 5-minute per-service deployments, eliminating cascading failure modes from synchronized releases and enabling weekly release cycles\n- Enables independent scaling: individual services can handle 10x traffic without scaling the entire system, reducing infrastructure costs and improving resource utilization\n- Allows domain teams to adopt technology stacks optimized for their specific problems rather than global constraints, enabling better long-term architectural flexibility\n- Reduces inter-team dependencies and coordination overhead: teams can deploy, scale, and debug independently without blocking each other on database schema changes\n- Improves time-to-market for features by removing queue time waiting for coordinated deployments and shared infrastructure\n\n### Negative Consequences\n- Requires implementing distributed systems patterns: eventual consistency replaces ACID transactions, demanding event-driven architecture with compensating transactions instead of rollback safety\n- Introduces significant network latency: inter-service calls add 50-100ms per hop; requires comprehensive circuit breakers, bulkheads, and caching strategies throughout the system\n- Demands new expertise in distributed systems, service meshes, and observability; current team requires 6-8 weeks of structured training on eventual consistency, distributed tracing, and Kubernetes\n- Increases operational complexity substantially: surface area grows from 1 deployment artifact to 10+ services requiring containerization, service mesh infrastructure (Istio), Kubernetes orchestration, and comprehensive monitoring\n- Requires significant upfront investment in infrastructure and tooling before realizing benefits, with a 4-6 week migration period during which both systems must run in parallel\n\n### Subsequent ADRs Triggered by This Decision\n- Service mesh selection (Istio vs. Linkerd for inter-service communication and observability)\n- Distributed tracing implementation (Jaeger vs. Zipkin vs. Datadog)\n- API gateway and edge routing strategy (Kong vs. Ambassador vs. Envoy)\n\n### Recommended Review Timing\nReview at day 30 to validate 5-minute deployment target and measure inter-service latency against 50-100ms assumption. Conduct follow-up at day 90 to assess team training progress and operational maturity.",
    "score": 3.6240896358543413,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": false
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": false
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": false
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": false
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": true
        },
        {
          "name": "Addresses root cause from context",
          "passed": false
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": false
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  },
  {
    "testCaseId": "test_002",
    "testCaseName": "Frontend Framework Migration",
    "phase": "phase3",
    "output": "# Frontend Framework Migration\n\n## Status\nProposed\n\n## Context\nOur 5-year-old jQuery-based admin dashboard has become unmaintainable.\n        It takes new developers 6 weeks to become productive. The codebase has no tests.\n        We're losing features to competitors with better UX. Customer feedback shows frustration with performance.\n        Our team of 8 frontend developers spends 40% of time on bug fixes rather than features.\n        Modern frameworks offer better component reusability and testing support.\n\n## Decision\nWe considered Angular (steep learning curve, 8-week ramp-up) and Vue (smaller ecosystem, less team expertise available), but will migrate our jQuery-based admin dashboard to React with TypeScript, establishing a shared component library (Storybook) used across all four frontend services. This directly addresses the 6-week onboarding time for new frontend developers and solves the 40% of engineering effort spent on bugs rather than features.\n\n## Consequences\n\n### Positive Consequences\n- Reduces developer onboarding from 6 weeks to 2 weeks by providing a well-documented component library, consistent patterns, and strong type safety across all frontend applications\n- Enables comprehensive automated testing: component test coverage increases from 0% to 80%+ in the first quarter through Jest and React Testing Library, making integration testing feasible and reliable\n- Reduces bug-related work from 40% to 10% of sprint velocity through TypeScript type safety preventing silent runtime errors and React component isolation preventing state leaks\n- Improves frontend performance significantly: bundle optimization and code-splitting reduce initial page load from 8s to 2s; lazy-loading reduces time-to-interactive from 12s to 4s\n- Creates a reusable asset that accelerates development of new frontend applications, multiplying the value of the initial investment\n\n### Negative Consequences\n- Requires React and TypeScript expertise that current jQuery-focused team lacks; team needs 4-week intensive training before achieving target code velocity and productivity\n- Migration effort spans 6-8 weeks of parallel development: requires maintaining both jQuery and React codebases simultaneously to avoid user-facing downtime or regressions\n- Increases build infrastructure complexity significantly with new toolchain (Webpack/Vite), module bundling, tree-shaking, and npm dependency management\n- Introduces npm ecosystem security and supply-chain risks; team must implement dependency scanning (Snyk/Dependabot) and maintain security practices for managing transitive dependencies\n- Requires new DevOps capabilities: source map management, production debugging, and build optimization expertise that current team may not possess\n\n### Subsequent ADRs Triggered by This Decision\n- Component library strategy (Storybook setup, versioning, and release practices)\n- State management approach (Redux vs. Zustand vs. React Context for shared state)\n- Frontend testing framework decision (Jest + React Testing Library vs. Cypress for E2E)\n\n### Recommended Review Timing\nReview after first 3 quarterly releases to validate 2-week onboarding target and measure bug reduction from 40% to 10%. Conduct follow-up sprint retrospective at 6 weeks to assess team velocity impact.",
    "score": 3.7361344537815118,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": false
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": false
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": false
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": false
        },
        {
          "name": "Addresses root cause from context",
          "passed": true
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": false
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  },
  {
    "testCaseId": "test_003",
    "testCaseName": "Database Technology Selection",
    "phase": "phase3",
    "output": "# Database Technology Selection\n\n## Status\nProposed\n\n## Context\nOur relational database stores 500GB of primarily unstructured operational logs and events.\n        Queries for analytics take 30+ minutes. Compliance requires we retain data for 7 years.\n        We're running out of disk space despite aggressive archiving.\n        Data structure is mostly key-value pairs with variable attributes.\n        Current quarterly costs are $150k for database infrastructure alone.\n\n## Decision\nWe considered column-based relational databases (expensive for this scale, $200k+ annual cost) and aggressive archiving (doesn't solve 30-minute query times), but will migrate our 500GB relational database containing primarily unstructured operational logs to a time-series database, implementing rolling retention that keeps raw data for 30 days and only aggregated metrics beyond that. This solves the $150k quarterly storage cost and 30-minute analytics query latencies that currently block business decision-making.\n\n## Consequences\n\n### Positive Consequences\n- Reduces storage costs from $150k quarterly to $37.5k quarterly through compression and intelligent retention policies, achieving 75% cost savings and improving quarterly margins\n- Improves analytics query performance from 30 minutes to 30 seconds for typical reports through columnar storage and native time-series optimization, enabling business users to self-serve analytics\n- Enables real-time operational dashboards and automated alerts by supporting sub-second queries on recent data (last 24 hours), allowing immediate detection and response to system anomalies\n- Enforces automatic compliance with data deletion regulations (GDPR, CCPA) through granular, policy-based retention that requires no manual intervention or audit procedures\n- Provides scalability path for growing data volume: time-series databases scale horizontally with data volume, unlike relational databases which hit hard limits\n\n### Negative Consequences\n- Requires zero-downtime migration of 500GB of data: dual-write period during migration increases database load by 20%, requiring temporary capacity upgrade and careful coordination\n- Requires analytics team retraining on time-series query semantics: traditional JOIN operations become impossible; data models must restructure around time-series events, estimated 3-4 weeks learning curve\n- Eliminates relational query capabilities: complex analytics queries requiring JOINs cannot be performed; historical analysis becomes difficult after 30-day retention window for raw data\n- Increases operational complexity if self-hosted: time-series database clustering, replication, and backup procedures differ significantly from relational databases; requires either $5-10k/month managed service or dedicated ops expertise\n- Requires application code changes to emit data in time-series format rather than relational records, affecting all services that contribute to analytics\n\n### Subsequent ADRs Triggered by This Decision\n- Backup and disaster recovery strategy for time-series systems\n- Real-time alerting platform selection (Prometheus AlertManager vs. PagerDuty vs. Datadog)\n- Data retention and compliance automation tooling (Kubernetes CronJobs vs. managed service)\n\n### Recommended Review Timing\nReview at day 60 to validate cost savings against $37.5k quarterly target and verify query performance improvements from 30 minutes to 30 seconds. Conduct follow-up at 6 months for compliance audit results.",
    "score": 4.193277310924369,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": true
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": false
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": true
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": true
        },
        {
          "name": "Addresses root cause from context",
          "passed": true
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": false
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  },
  {
    "testCaseId": "test_004",
    "testCaseName": "Authentication Strategy",
    "phase": "phase3",
    "output": "# Authentication Strategy\n\n## Status\nProposed\n\n## Context\nCurrently, each service manages its own user authentication using session cookies.\n        This causes inconsistent security policies and hard-to-audit login attempts.\n        We have 8 different services with 8 different password policies.\n        Security audit flagged 12 vulnerabilities related to inconsistent auth implementation.\n        New compliance requirement mandates multi-factor authentication across all services.\n\n## Decision\nWe considered per-service OAuth implementations (requires auditing 8 codebases, unmaintainable) and internal auth service (months to build, high risk), but will implement OAuth 2.0 single-sign-on (SSO) through a managed identity provider (Okta), consolidating authentication from eight separate service implementations into centralized, audited access control. This resolves 12 OWASP authentication vulnerabilities from inconsistent implementations and enables mandatory multi-factor authentication across all services.\n\n## Consequences\n\n### Positive Consequences\n- Eliminates 12 OWASP authentication vulnerabilities by consolidating session management, password handling, and credential validation into a single, professionally audited service; reduces security review burden from eight separate implementations\n- Enables organization-wide password policy enforcement, MFA mandatory requirement, and conditional access rules; compliance audits become straightforward, repeatable, and can be run in minutes instead of weeks\n- Simplifies user credential management: single password reset and single MFA enrollment grants access to all eight services; eliminates cognitive load and support tickets from managing multiple credentials\n- Reduces ongoing security maintenance burden: security team performs one quarterly review instead of auditing eight implementations separately; patches and security updates apply globally\n- Provides audit trail capability: centralized logging of all authentication events enables security monitoring, suspicious activity detection, and regulatory compliance reporting\n\n### Negative Consequences\n- Creates single point of failure: authentication service outage immediately blocks all dependent services globally; requires 99.99% uptime SLA, comprehensive disaster recovery, and real-time failover mechanisms\n- Increases authentication latency: every user request requires round-trip to auth service (50-150ms added latency per request); requires aggressive token caching strategy, offline-capable UI patterns, and refresh token logic\n- Requires rewriting authentication flows in eight different services: estimated 4-6 weeks engineering effort for coordinated rollout with zero-downtime migration using token translation and dual authentication\n- Introduces external dependency on managed identity provider: adds $3-5k monthly recurring cost, vendor lock-in, and integration complexity; requires new OAuth implementation knowledge across all service teams\n- Adds network dependency and reliability concern: if Okta experiences latency or outage, all services are affected; requires careful consideration of fallback and degradation strategies\n\n### Subsequent ADRs Triggered by This Decision\n- Token caching strategy (in-memory vs. Redis vs. local browser storage)\n- Session timeout and token lifetime policies\n- Multi-tenancy and cross-organization access control patterns\n\n### Recommended Review Timing\nReview at day 14 to verify zero security incidents and measure authentication latency impact against 50-150ms assumption. Conduct follow-up at day 30 to validate SLA uptime performance.",
    "score": 4.1955182072829125,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": true
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": true
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": false
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": false
        },
        {
          "name": "Addresses root cause from context",
          "passed": true
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": true
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  },
  {
    "testCaseId": "test_005",
    "testCaseName": "API Versioning Strategy",
    "phase": "phase3",
    "output": "# API Versioning Strategy\n\n## Status\nProposed\n\n## Context\nOur public API has 1,200 active integrations with third-party developers.\n        We need to make breaking changes to support new business requirements.\n        We've deprecated v1 twice already, each time causing partner outages and support burden.\n        Current approach of maintaining multiple endpoint versions causes code duplication and inconsistency.\n        Partners request longer deprecation timelines (currently 6 months, asking for 18 months).\n\n## Decision\nWe considered per-service OAuth implementations (requires auditing 8 codebases, unmaintainable) and internal auth service (months to build, high risk), but will implement OAuth 2.0 single-sign-on (SSO) through a managed identity provider (Okta), consolidating authentication from eight separate service implementations into centralized, audited access control. This resolves 12 OWASP authentication vulnerabilities from inconsistent implementations and enables mandatory multi-factor authentication across all services.\n\n## Consequences\n\n### Positive Consequences\n- Eliminates 12 OWASP authentication vulnerabilities by consolidating session management, password handling, and credential validation into a single, professionally audited service; reduces security review burden from eight separate implementations\n- Enables organization-wide password policy enforcement, MFA mandatory requirement, and conditional access rules; compliance audits become straightforward, repeatable, and can be run in minutes instead of weeks\n- Simplifies user credential management: single password reset and single MFA enrollment grants access to all eight services; eliminates cognitive load and support tickets from managing multiple credentials\n- Reduces ongoing security maintenance burden: security team performs one quarterly review instead of auditing eight implementations separately; patches and security updates apply globally\n- Provides audit trail capability: centralized logging of all authentication events enables security monitoring, suspicious activity detection, and regulatory compliance reporting\n\n### Negative Consequences\n- Creates single point of failure: authentication service outage immediately blocks all dependent services globally; requires 99.99% uptime SLA, comprehensive disaster recovery, and real-time failover mechanisms\n- Increases authentication latency: every user request requires round-trip to auth service (50-150ms added latency per request); requires aggressive token caching strategy, offline-capable UI patterns, and refresh token logic\n- Requires rewriting authentication flows in eight different services: estimated 4-6 weeks engineering effort for coordinated rollout with zero-downtime migration using token translation and dual authentication\n- Introduces external dependency on managed identity provider: adds $3-5k monthly recurring cost, vendor lock-in, and integration complexity; requires new OAuth implementation knowledge across all service teams\n- Adds network dependency and reliability concern: if Okta experiences latency or outage, all services are affected; requires careful consideration of fallback and degradation strategies\n\n### Subsequent ADRs Triggered by This Decision\n- Token caching strategy (in-memory vs. Redis vs. local browser storage)\n- Session timeout and token lifetime policies\n- Multi-tenancy and cross-organization access control patterns\n\n### Recommended Review Timing\nReview at day 14 to verify zero security incidents and measure authentication latency impact against 50-150ms assumption. Conduct follow-up at day 30 to validate SLA uptime performance.",
    "score": 4.038655462184873,
    "details": {
      "completeness": [
        {
          "name": "Has Status section",
          "passed": true
        },
        {
          "name": "Has Context section",
          "passed": true
        },
        {
          "name": "Has Decision section",
          "passed": true
        },
        {
          "name": "Has Consequences section",
          "passed": true
        },
        {
          "name": "Status is one of: Proposed, Accepted, Superseded, Deprecated",
          "passed": true
        },
        {
          "name": "Decision is non-empty (>100 chars)",
          "passed": true
        },
        {
          "name": "Consequences section has content (>100 chars)",
          "passed": false
        }
      ],
      "clarity": [
        {
          "name": "No vague language: \"better\"",
          "passed": true
        },
        {
          "name": "No vague language: \"improve\"",
          "passed": true
        },
        {
          "name": "No vague language: \"optimize\"",
          "passed": true
        },
        {
          "name": "No vague language: \"easier\"",
          "passed": true
        },
        {
          "name": "No vague language: \"efficient\"",
          "passed": true
        },
        {
          "name": "Decision uses clear action verbs",
          "passed": true
        },
        {
          "name": "Context clearly states the problem",
          "passed": false
        }
      ],
      "consequencesBalance": [
        {
          "name": "Lists positive consequences",
          "passed": true
        },
        {
          "name": "Lists negative consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 positive consequences",
          "passed": true
        },
        {
          "name": "Has at least 2 negative consequences",
          "passed": false
        },
        {
          "name": "Uses clear consequence language",
          "passed": true
        }
      ],
      "technicalSoundness": [
        {
          "name": "Decision is specific (not generic)",
          "passed": true
        },
        {
          "name": "Decision is implementable",
          "passed": true
        },
        {
          "name": "No implementation details (\"use X framework\")",
          "passed": false
        },
        {
          "name": "Addresses root cause from context",
          "passed": false
        },
        {
          "name": "Consequences are realistic",
          "passed": true
        }
      ],
      "industryAlignment": [
        {
          "name": "Follows Michael Nygard ADR format",
          "passed": true
        },
        {
          "name": "Decision focuses on \"why\" not \"how\"",
          "passed": true
        },
        {
          "name": "Context explains constraints/alternatives",
          "passed": false
        }
      ]
    }
  }
]